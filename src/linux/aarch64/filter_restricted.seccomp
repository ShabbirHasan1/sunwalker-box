# TODO: handle multiarch gracefully instead of killing the process
A = arch
A == ARCH_AARCH64 ? next : kill

A = sys_number

A == close ? first_arg_fd : next
A == 436 ? first_arg_fd : next  # close_range
A == read ? first_arg_fd : next
A == pread64 ? first_arg_fd : next
A == readv ? first_arg_fd : next
A == dup ? first_arg_fd : next
A == preadv ? first_arg_fd : next
A == preadv2 ? first_arg_fd : next

A == dup3 ? first_two_args_fds : next

A == fcntl ? fcntl : next
A == ioctl ? ioctl : next
A == lseek ? lseek : next
A == mmap ? mmap : next
A == prctl ? prctl : next
A == sysinfo ? trace : next
A == reboot ? reboot : next

A == getxattr ? allow : next
A == lgetxattr ? allow : next
A == fgetxattr ? allow : next
A == listxattr ? allow : next
A == llistxattr ? allow : next
A == flistxattr ? allow : next
A == getcwd ? allow : next
A == eventfd2 ? allow : next  # for Ruby
A == ioprio_get ? allow : next
A == statfs ? allow : next
A == fstatfs ? allow : next
A == faccessat ? allow : next
A == chdir ? allow : next
A == fchdir ? allow : next
A == quotactl ? allow : next
A == getdents64 ? allow : next
A == pselect6 ? allow : next
A == ppoll ? allow : next
A == readlinkat ? allow : next
A == newfstatat ? allow : next
A == 80 ? allow : next  # newfstat
A == sync ? allow : next
A == sync_file_range ? allow : next
A == capget ? allow : next
A == personality ? allow : next
A == exit ? allow : next
A == exit_group ? allow : next
A == waitid ? allow : next
A == set_tid_address ? allow : next
A == futex ? allow : next
A == set_robust_list ? allow : next
A == get_robust_list ? allow : next
A == nanosleep ? allow : next
A == getitimer ? allow : next
A == setitimer ? allow : next
A == timer_create ? allow : next
A == timer_gettime ? allow : next
A == timer_getoverrun ? allow : next
A == timer_settime ? allow : next
A == timer_delete ? allow : next
A == clock_gettime ? allow : next
A == clock_getres ? allow : next
A == clock_nanosleep ? allow : next
A == sched_getscheduler ? allow : next
A == sched_getparam ? allow : next
A == sched_getaffinity ? allow : next
A == sched_yield ? allow : next
A == sched_get_priority_max ? allow : next
A == sched_get_priority_min ? allow : next
A == sched_rr_get_interval ? allow : next
A == restart_syscall ? allow : next
A == kill ? allow : next
A == tkill ? allow : next
A == tgkill ? allow : next
A == sigaltstack ? allow : next
A == rt_sigsuspend ? allow : next
A == rt_sigaction ? allow : next
A == rt_sigprocmask ? allow : next
A == rt_sigpending ? allow : next
A == rt_sigtimedwait ? allow : next
A == rt_sigqueueinfo ? allow : next
A == rt_sigreturn ? allow : next
A == getpriority ? allow : next
A == getresuid ? allow : next
A == getresgid ? allow : next
A == times ? allow : next
A == getpgid ? allow : next
A == getsid ? allow : next
A == getgroups ? allow : next
A == uname ? allow : next
A == getrlimit ? allow : next
A == setrlimit ? allow : next
A == getrusage ? allow : next
A == umask ? allow : next
A == getcpu ? allow : next
A == gettimeofday ? allow : next
A == getpid ? allow : next
A == getppid ? allow : next
A == getuid ? allow : next
A == geteuid ? allow : next
A == getgid ? allow : next
A == getegid ? allow : next
A == gettid ? allow : next
A == getpeername ? allow : next
A == readahead ? allow : next
A == brk ? allow : next
A == munmap ? allow : next
A == mremap ? allow : next
A == execve ? allow : next
A == fadvise64 ? allow : next
A == mprotect ? allow : next
A == msync ? allow : next
A == mincore ? allow : next
A == madvise ? allow : next
A == remap_file_pages ? allow : next
A == get_mempolicy ? allow : next
A == rt_tgsigqueueinfo ? allow : next
A == wait4 ? allow : next
A == prlimit64 ? allow : next
A == syncfs ? allow : next
A == process_vm_readv ? allow : next
A == process_vm_writev ? allow : next
A == sched_getattr ? allow : next
A == getrandom ? allow : next
A == execveat ? allow : next
A == membarrier ? allow : next
A == statx ? allow : next
A == 293 ? allow : next  # rseq
A == 439 ? allow : next  # faccessat2
A == 440 ? allow : next  # process_madvise
A == 449 ? allow : trace  # futex_waitv

first_two_args_fds:
A = args[1]
A &= 0xffffffff
A < 3 ? trace : first_arg_fd

first_arg_fd:
A = args[0]
A &= 0xffffffff
A < 3 ? trace : allow

fcntl:
A = args[0]
A &= 0xffffffff
A < 3 ? next : allow
A = args[1]
A &= 0xffffffff
A == 1 ? allow : next  # F_GETFD
A == 2 ? allow : next  # F_SETFD
A == 3 ? allow : trace  # F_GETFL

ioctl:
A = args[0]
A &= 0xffffffff
A < 3 ? next : allow
A = args[1]
# These will return ENOTTY/ENOTSOCK anyway
A == 0x5401 ? allow : next  # TCGETS
A == 0x540f ? allow : trace  # TIOCGPGRP

lseek:
A = args[0]
A &= 0xffffffff
A >= 3 ? allow : next
# Disallow seeking to anywhere but the beginning
A = args[1]
A == 0 ? next : trace
A = args[2]
A == 0 ? allow : next  # SEEK_SET
A == 1 ? allow : trace  # SEEK_CUR

mmap:
# A = args[3]
# A &= 0x02  # MAP_PRIVATE
# A == 0 ? trace : next
A = args[4]
A &= 0xffffffff
A < 3 ? trace : allow

prctl:
A = args[0]
A &= 0xffffffff
A == 2 ? allow : next  # PR_GET_PDEATHSIG
A == 3 ? allow : next  # PR_GET_DUMPABLE
A == 7 ? allow : next  # PR_GET_KEEPCAPS
A == 13 ? allow : next  # PR_GET_TIMING
A == 16 ? allow : next  # PR_GET_NAME
A == 21 ? allow : next  # PR_GET_SECCOMP
A == 23 ? allow : next  # PR_CAPBSET_READ
A == 25 ? allow : next  # PR_GET_TSC
A == 27 ? allow : next  # PR_GET_SECUREBITS
A == 30 ? allow : next  # PR_GET_TIMERSLACK
A == 34 ? allow : next  # PR_MCE_KILL_GET
A == 37 ? allow : next  # PR_GET_CHILD_SUBREAPER
A == 39 ? allow : next  # PR_GET_NO_NEW_PRIVS
A == 40 ? allow : next  # PR_GET_TID_ADDRESS
A == 41 ? allow : next  # PR_SET_THP_DISABLE
A == 42 ? allow : next  # PR_GET_THP_DISABLE
A == 47 ? pr_cap_ambient : trace  # PR_CAP_AMBIENT

pr_cap_ambient:
A = args[1]
A == 1 ? allow : trace  # PR_CAP_AMBIENT_IS_SET

reboot:
A = args[0]
A &= 0xffffffff
A == 0xfee1dead ? next : einval
A = args[1]
A &= 0xffffffff
A == 0x11092001 ? next : allow
A = args[2]
A &= 0xffffffff
A == 0 ? skip : enosys  # reboot(..., 0) = 0 is prefork mode marker

trace:
return TRACE

allow:
return ALLOW

kill:
return KILL

einval:
return ERRNO(22)  # EINVAL

enosys:
return ERRNO(38)  # ENOSYS

skip:
return ERRNO(0)
